% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model_constructors.R
\name{multi_custom_derivatives}
\alias{multi_custom_derivatives}
\title{Define a custom derivatives UDE with multiple time seriess}
\usage{
multi_custom_derivatives(
  data,
  derivs,
  initial_parameters,
  covariates = NULL,
  neural_network_inputs = 1,
  neural_network_outputs = 1,
  hidden_units = 10,
  time_column_name = "time",
  series_column_name = "series",
  proc_weight = 1,
  obs_weight = 1,
  reg_weight = 10^-6,
  reg_type = "L2",
  l = 0.25,
  extrap_rho = 0.1,
  bayesian = FALSE,
  uid = gsub(x = format(Sys.time(), "\%Y\%m\%d\%H\%M\%OS6"), pattern = "[.]", replacement
    = "")
)
}
\arguments{
\item{data}{A data frame of observed state variables over time.}

\item{derivs}{A user-defined function of the form \code{derivs(u,nn,p,t)} where
\code{u} stores the value of the state variables, \code{nn} stores the neural network
outputs,\code{p} stores the model parameters, and \code{t} is time. The function should
save each ODE to \code{du[i]}, where \code{i} is an index for each time derivative.}

\item{initial_parameters}{A named list containing the model parameters stored
in \code{p}.}

\item{covariates}{A data frame of observed covariates (e.g., environmental
conditions) over time. This data frame must have the same column
name for time as the primary dataset, but the time points do not need to
match because the values of the covariates between time points included in
the data frame \code{covariates} are interpolated using a linear spline. Optional.}

\item{neural_network_inputs}{The number of input nodes of the neural network.}

\item{neural_network_outputs}{The number of output nodes of the neural network.}

\item{hidden_units}{Number of neurons in the single hidden layer.}

\item{time_column_name}{The column in \code{data} and \code{covariates} that contains
the time data, indicating when the observations were made.}

\item{series_column_name}{The column in \code{data} and \code{covariates} that contains
the series data, indicating the identifying information for the observations.}

\item{proc_weight}{Weight of the process error term \eqn{\nu_t} in the loss
function. The process weight controls how closely the model predictions
match the state estimates \eqn{\hat{u}_t}.}

\item{obs_weight}{Weight of the observation error term \eqn{\epsilon_t} in the loss
function. The observation weight controls how closely the state estimates
\eqn{\hat{u}_t} match the observations \eqn{y_t}. Smaller values of the observation weight
correspond to datasets with larger amounts of observation error and vice versa.}

\item{reg_weight}{Weight \eqn{\lambda} of the regularization penalty term in the loss
function.}

\item{reg_type}{Type of regularization used to mitigate overfitting.
Options are either "L1" (LASSO) or "L2" (ridge regression). The penalty term
added to the loss function is either the absolute value of the sum of
coefficients (L1) or the squared sum of coefficients (L2). Generally, the
default of "L2" should be used.}

\item{l}{Extrapolation parameter for forecasting.}

\item{extrap_rho}{Extrapolation parameter for forecasting.}

\item{bayesian}{Logical (\code{TRUE} or \code{FALSE}) for whether or not the UDE is a
Bayesian UDE.}

\item{uid}{A string that serves as a unique identifier to save the
model into Julia. It is not recommended to modify this parameter.}
}
\value{
An untrained custom derivatives UDE model containing all the defined parameters.
}
\description{
Define a custom derivatives UDE with multiple time seriess
}
\examples{
print("test")
}
